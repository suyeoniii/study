## 사용자 수에 따른 규모 확장성

### 단일 서버

웹 앱, 데이터베이스, 캐시가 전부 한 대의 서버에서 실행

1. 사용자는 도메인으로 웹사이트 접속
   - 도메인 이름을 DNS에 질의하여 IP주소로 변환
2. DNS에서 조회한 IP 주소 = 웹 서버 주소
3. 해당 IP 주소로 HTTP 요청
4. 요청 받은 웹 서버는 HTML페이지나 JSON으로 응답 반환

### 데이터베이스

- 웹/모바일 트래픽 처리 용도와 별도로 데이터베이스용으로 서버를 두어야함
- 웹 계층과 데이터 계층을 각각 독립적으로 확장할 수 있게됨
- 관계형 데이터베이스 또는 비관계형 데이터베이스를 사용할 수 있음

#### 비관계형 데이터베이스가 유리한 경우

- 낮은 응답 시간이 요구되는 경우
- 다루는 데이터가 비정형이라 관계형 데이터가 아닌 경우
- 데이터를 직렬화하거나 역직렬화 힐 수 있기만 하면 되는 경우
- 아주 많은 양의 데이터를 저장해야할 때

### 수직적 규모 확장 vs 수평적 규모 확장

#### 수직적 규모 확장 (스케일 업)

- 서버에 고사양 자원(CPU, RAM 등)을 추가하는 것
- 단순하다는 장점
- 확장에 한계가 있음
- 장애 시 자동복구, 다중화 방안이 지원되지 않음

#### 수평적 규모 확장 (스케일 아웃)

- 서버를 추가하여 성능을 개선하는 것
- 대규모 애플리케이션인 경우 더 적합함

### 로드밸런서

- 웹 서버의 트래픽 부하를 고르게 분산하는 역할
- 보안을 위해 서버 간 통신에는 사설 IP 주소가 이용됨 (같은 네트워크에 속한 서버 사이 통신에만 쓰일 수 있음)
- 부하 분산 집합에 또 하나의 웹 서버를 추가하는 경우 장애를 자동복구하는 문제가 해소됨
- = 서버1이 다운되면 서버2로 트래픽이 전송되므로 전체가 다운되는 일이 방지됨
- 2대의 서버에서 더 늘려야 하는 경우에도 서버만 추가하면 로드밸런서가 트래픽을 자동으로 분산시켜줌

### 데이터베이스 다중화

- 장애의 자동복구를 위함
- 데이터베이스를 master, slave로 나누고 데이터 원본은 master에, slave에는 복사본을 저장하는 방식을 사용함
- master 데이터베이스에서만 쓰기 연산이 가능하고 slave 데이터베이스에서는 읽기 연산만 가능함
- 쓰기 작업은 master 데이터베이스로 전달되고, 읽기 작업은 slave 데이터베이스로 전달되어 부하가 분산됨
- 대부분 읽기 연산의 비중이 높기때문에 slave 데이터베이스의 수가 master보다 더 많음
- 데이터베이스 서버 중 일부의 데이터가 파괴되어도 여러 서버에 분산되어있기 때문에 데이터를 보존할 수 있음
- master 데이터베이스가 다운되어 slave 데이터베이스에서 쓰기 작업도 수행해야하는 경우, slave 데이터베이스에 있는 데이터가 최신 데이터가 아닐 수도 있다는 문제가 있음
- -> 복구 스크립트를 돌려서 해결할 수 있음. 그 외에 다중 마스터, 원형 다중화 등의 방식을 도입할 수도 있음

### 캐시

- 응답 시간 개선
- 자주 참조되는 데이터를 메모리 안에 두고, 뒤이은 요청이 보다 빨리 처리될 수 있도록 하는 저장소
- 캐시 계층은 데이터베이스보다 훨씬 빠름
- 웹 서버에서는 캐시 데이터 존재 여부를 먼저 확인하고, 없으면 DB를 조회하고 캐시에 씀 (=읽기 주도형 캐시 전략)
  - [캐시 읽기, 쓰기 전략](https://codeahoy.com/2017/08/11/caching-strategies-and-how-to-choose-the-right-one/)
  - 첫번째 요청은 캐싱되어있지 않아 응답시간이 오래걸릴 수 있는데, 미리 요청을 해서 캐싱시켜놓는 방법도 있음 (=pre-heating, warming)
- 데이터 갱신은 자주 일어나지 않지만, 참조는 빈번히 일어나는 경우 유리
- 캐시는 휘발성 메모리에 두므로 영속적으로 보관해야하는 데이터는 바람직하지 않음
- 만료 기간을 적절히 두어, 만료 시간이 길어 데이터가 너무 오래되거나, 만료 시간이 짧아 데이터베이스 읽기를 자주 해야하는 것을 피해야함
- 캐시 서버가 한 대인 경우 해당 서버는 SPOF(Single Point of Failure)이 될 수 있음 -> 여러 지역에 분산하는 것이 바람직함
- 캐시 메모리를 너무 작게 잡으면, 데이터가 캐시에서 너무 자주 밀려버려 캐시 성능 떨어짐
  - 캐시 메모리를 과할당하면 캐시에 보관될 데이터가 갑자기 늘어났을 때 생길 문제 방지할 수 있음
- 데이터 방출(eviction) 정책: 캐시가 꽉차버리면 기존 데이터를 내보내야하는데, 어떤 데이터를 내보낼지 결정하는 정책
  - LRU 정책 (마지막으로 사용된 시점이 가장 오래된 것)이 가장 자주 사용됨
  - LFU 정책 (사용빈도가 가장 낮은 데이터를 내보냄)
  - FIFO 정책 (가장 먼저 캐시에 들어온 데이터를 내보냄)

#### 콘텐츠 전송 네트워크 (CDN)

- 정적콘텐츠를 전송하는데 쓰이는, 지리적으로 분산된 서버의 네트워크
- 동적 콘텐츠 캐싱
  - request path, query string, cookie, request header등의 정보에 기반하여 HTML 페이지 캐시
- 동작
  - 사용자가 웹사이트를 방문하면, 그 사용자에게 가장 가까운 CDN 서버가 정적 콘텐츠를 전달함
  - 사용자가 CDN 서버로부터 멀수록 전송 속도가 느림
  1.  CDN 도메인으로 접근
  2.  CDN 서버의 캐시에 해당 이미지가 없는 경우, 원본 서버에 요청해서 파일을 가져옴 (원본 서버 = S3 등)
  3.  원본 서버가 파일을 CDN 서버에 반환. 응답 헤더에는 TTL (Time To Live = 얼마나 오래 캐시될 수 있는지)이 포함됨
  4.  CDN 서버는 파일을 캐시하고, 반환함. TTL에 명시된 시간이 끝날 때까지 캐시됨
  5.  다른 클라이언트의 요청이 들어왔을때 캐시 서버의 파일이 만료되지 않았으면 반환함.

##### 고려해야할 사항

- 보통 제 3사업자에 의해 운영됨
  - CloudFlare, Akamai, Amazon CloudFront 등
- 데이터 전송 양에 따라 요금 지불
- 자주 사용되지 않는 콘텐츠를 캐싱하는 것은 이득이 크지 않으므로 빼는 것을 고려해보아야함
- 적절한 만료 시한 설정: 시의성이 중요한 콘텐츠의 경우 만료 시점을 장 정해야함
- CDN 장애 대처 방안: CDN이 다운되었을 경우, 일시적으로 원본 서버에서 직접 가져오도록 구성하는 것이 필요함
- 콘텐츠 무효화 방법: 아직 만료되지 않았더라고, CDN에서 제거할 수 있음
  - CDN 서비스 사업자가 제공하는 API 사용
  - [AWS Cloudfront GUI](https://stackoverflow.com/questions/1086240/how-can-i-update-files-on-amazons-cdn-cloudfront), CLI
  - 콘텐츠의 다른 버전을 서비스하도록 오브젝트 버저닝 이용, 새로운 버전을 지정하기 위해서는 URL의 마지막 부분에 버전 번호를 안자로 주면됨 (예: `http://example.com/image.jpg?v=2`)
  - +새로운 파일명 사용

### 무상태 웹 계층

- 웹 계층을 수평적으로 확장하기
- 사용자 세션과 같은 상태정보를 웹 계층에서 제거해야함
- 상태 정보를 관계형 데이터베이스, NoSql같은 지속성 저장소에 보관하고, 필요할 때 가져오기
- 이렇게 구성된 웹 계층 = 무상태 웹계층

#### 상태 정보 의존적인 아키텍처

- 상태 정보를 보관하는 서버는 상태를 유지하여 요청들 사이에 공유되도록함
- 무상태 서버에는 이런 장치가 없음
- -> 웹 계층을 수평적으로 늘리면 각 서버들이 상태 정보를 가지고 있으면 안되고, 따로 공유 저장소를 두어 상태 정보를 관리해야함
- 서버가 상태를 가지게하면, 같은 클라이언트의 요청이 같은 서버로만 전달되어야하는데, 로드밸런서로 이걸 처리할 수는 있지만 로드밸런서에 부담이됨
- [AWS ELB](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-sticky-sessions.html)

#### 무상태 아키텍처

- 사용자의 요청이 어떤 웹서버로든 전달될 수 있음
- 상태 정보를 공유저장소에 보관하고, 필요할때 가져옴
- 규모 확장이 쉬움
- Memcached/Redis, NoSQL

### 데이터 센터

- 지리적 라우팅 (geoDNS-routing)을 통해 사용자 위치에 따라 다른 데이터센터로 안내됨
- 데이터 센터 중 일부에 장애가 생기면, 문제없는 데이터센터로 모든 요청이 전송됨
- 데이터를 여러 데이터센터에 걸쳐서 다중화해야함

### 메시지 큐

- 메시지의 무손실, 메시지 큐에 보관된 메세지는 소비자가 꺼낼 때까지 안전히 보관되는 특성
- 비동기 통신을 지원함
- 메세지의 버퍼 역할
- 생산자 또는 발행자 (producer, publisher) 라고 불리는 입력 서비스가 메세지를 만들어 메세지 큐에 발행
- 메세지 큐를 사용하면 서비스, 서버간 결합이 느슨해져서 규모 확장성이 보장되어야하는 안정적 애플리케이션 구성에 좋다
- 예) 사진 보정 애플리케이션
  - 보정 작업 큐를 만들어, 웹 서버는 보정 작업 요청이 들어오면 큐에 넣음
  - 사진 보정 작업 프로세스는 큐를 확인해서 작업을 처리함

### 로그, 메트릭, 자동화

- 로그, 메트릭, 자동화는 소규모 웹사이트에는 꼭 필요하지는 않음
- 로그: 에러로그 수집, 여러 서버의 로그를 단일 서비스로 모아주는 도구 활용하면 좋음
  - 도구 예시: Datadog, Sentry
- 메트릭
  - 추적할 가치가 있는 데이터들
  - 잘 수집하면 사업 현황의 유용한 정보를 얻을 수 있음
  - 시스템의 현재 상태를 손쉽게 파악할 수 있음
  - 호스트 단위 메트릭: CPU, 메모리, 디스크IO
  - 종합 메트릭: 데이터베이스 계층의 성능, 캐시 계층의 성능 등
  - 핵심 비즈니스 메트릭: 일별 능동 사용자(DAU), 수익, 재방문(retention)
- 자동화
  - CI
  - 자동화된 테스트

### 데이터베이스 규모 확장

- 데이터베이스 증설

#### 수직적 확장

- 기존 서버에 더 많은 고성능의 자원 증설
- 하드웨어 증설에도 한계가 있음
- SPOF로 인한 위험성
- 비용이 많이듬

#### 수평적 확장

- 샤딩이라고도 함
- 서버를 더 추가해서 성능 향상
- 데이터베이스를 샤드라고 부르는 작은 단위로 분할
- 샤드끼리는 같은 스키마를 쓰지만, 데이터는 중복이 없음
- 어느 샤드에 넣을지는 사용자 ID에 따라 정함

##### 샤딩

- 샤딩 키를 어떻게 정할건지?를 고려해야함
- 샤딩 키 = 파티션 키
- 데이터가 어떻게 분산될지 하나 이상의 컬럼으로 구성됨
- 샤딩키를 보고 올바른 데이터베이스에 질의를 보냄
- 샤딩키를 정할땐 데이터가 고르게 분할되도록 해야함
- 재샤딩
  - 데이터가 많아져서 하나의 샤드로는 더이상 감당이 어려울 때
  - 특정 샤드에 데이터가 몰렸을 때 (샤드 소진)
  - 샤드 키를 계산하는 함수를 변경하고 데이터 재배치
  - 이 문제는 안정 해시 기법으로 해결가능
- 유명인사 문제
  - 특정 샤드에 질의가 집중되어 서버에 과부하 걸림
  - 해결방법: 문제가되는 데이터의 ID를 해시하여 다른 샤드로 보내기
- 조인과 비정규화
  - 일단 하나의 데이터 베이스를 여러 샤드 서버로 쪼개고 나면, 여러 샤드의 데이터를 조인하기 어려워짐
  - 해결방법: 비정규화하여 질의가 한 테이블에서 이루어질 수 있도록 함
- 관계형 데이터베이스가 요구되지 않는 데이터는 NoSql로 이전함

### 정리

- 웹 계층은 무상태 계층으로
- 모든 계층에 ㅏ중화 도임
- 가능한 한 많은 데이터 캐시
- 여러 데이터센터 지원
- 정적 콘텐츠는 CDN 통해서 서비스
- 데이터 계층은 샤딩을 통해 규모 확장할 것
- 각 계층은 독집럭 서비스로 분할
- 시스템을 지속적으로 모니터링, 자동화 도구 활용

#### 참고문헌

1. https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol
2. https://blog.teamtreehouse.com/should-you-go-beyond-relational-databases
3. https://en.wikipedia.org/wiki/Replication_(computing)
4. https://en.wikipedia.org/wiki/Multi-master_replication
5. https://dev.mysql.com/doc/refman/5.7/en/mysql-cluster-replication-multi-master.html
6. https://codeahoy.com/2017/08/11/caching-strategies-and-how-to-choose-the-right-one/
7. Facebook, Scaling Memcache at
8. https://en.wikipedia.org/wiki/Single_point_of_failure
9. https://aws.amazon.com/ko/cloudfront/dynamic-content/
10. https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-sticky-sessions.html
11. https://netflixtechblog.com/active-active-for-multi-regional-resiliency-c47719f6685b
12. https://aws.amazon.com/ec2/instance-types/high-memory/
13. https://nickcraver.com/blog/2013/11/22/what-it-takes-to-run-stack-overflow/
14. http://highscalability.com/blog/2010/12/6/what-the-heck-are-you-actually-using-nosql-for.html
