## 키-값 저장소 설계

### 키-값 저장소

- 비관계형 데이터베이스
- 고유 식별자를 키로 가져야함
- 키는 유일한 값이고, 값은 키를 이용해서 접근가능
- 키가 짧은수록 성능이 좋음
- 다이나모DB, 카산드라, Redis, Memcached 등

### 문제 이해 및 설계 범위 확정

- 키-값 쌍의 크기는 10KB 이하
- 큰 데이터를 저장할 수 있어야함
- 높은 가용성 제공. 장애가 있어도 빨리 응답
- 높은 규모 확장성. 트래픽 양에 따라 자동적으로 서버 증설/삭제가 이루어져야함
- 데이터 일관성 수준은 조정 가능해야함
- 응답 지연시간이 짧아야함

### 단일 서버 키-값 저장소

- 단일 서버에 키-값 저장소를 구축
- 빠른 속도로 데이터를 저장하고 조회할 수 있음
- 모든 데이터를 메모리 안에 저장할 수 없을수도 있음
- 개선책
  - 데이터 압축
  - 자주쓰이는 데이터는 메모리에 저장하고 나머지는 디스크에 저장

### 분산 키-값 저장소

- 분산 해시 테이블
- 키-값 쌍을 여러 서버에 분산시킴

#### CAP 정리

- Consistency (일관성): 모든 노드가 동일한 데이터를 가지고 있어야함
- Availability (가용성): 모든 요청에 대해 응답을 받을 수 있어야함
- Partition Tolerance (파티션 감내, 분할 내성): 네트워크 문제로 인해 노드간 통신이 끊어져도 시스템이 정상적으로 동작해야함
- CAP 정리: 분산 시스템은 Consistency, Availability, Partition Tolerance 중 2개만 선택할 수 있음
- CP 시스템: 일관성과 파티션 감내를 선택
- AP 시스템: 가용성과 파티션 감내를 선택
- CA 시스템: 일관성과 가용성을 선택
- 분산시스템은 반드시 파티션 문제를 감내할 수 있도록 설계되어야하므로 실세계에 CA 시스템은 존재하지 않음

##### 이상적 상태

- 모든 노드가 동일한 데이터를 가지고 있음
- 파티션되는 상황이 일어나지 않으며 일관성과 가용성도 만족

##### 실세계의 분산 시스템

- 파티션 문제를 피할 수 없음
- 일관성과 가용성 사이에서 하나를 선택해야함
- 일관성을 선택한다면 데이터 불일치 문제를 피하기 위해 쓰기 연산은 중단시켜야함 -> 가용성은 깨짐
  - 은행 시스템
- 가용성을 선택한다면 계속 읽기 연산을 허용해야함 -> 일관성은 깨짐
  - SNS

#### 시스템 컴포넌트

- 데이터 파티션
- 데이터 다중화 (Replication)
- 일관성 (Consistency)
- 일관성 불일치 해소 (inconsistency resolution)
- 장애 처리
- 시스템 아키텍처 다디어그램
- 쓰기 경로 (Write Path)
- 읽기 경로 (Read Path)

##### 데이터 파티션

- 데이터를 여러 서버에 분산시키는 것
- 고려해야하는 문제
  - 데이터를 여러 서버에 고르게 분산시키는 방법
  - 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가
- 안정 해시
  - 규모 확장 자동화: 서버가 자동으로 추가되거나 삭제되도록 만들 수 있음
  - 다양성: 서버의 용량에 맞게 가상 노드 수를 조정할 수 있음

##### 데이터 다중화

- 높은 가용성과 안정성을 확보하기 위해 데이터를 N개 서버에 비동기적으로 다중화해야함
- 가상 노드를 사용하면 선택한 N개의 노드가 대응될 실제 물리 서버의 개수가 N보다 작아질 수 있음
  - 같은 물리 서버를 중복 선택하지 않도록 해야함
- 데이터의 사본은 다른 데이터센터에 저장해야함
  - 데이터센터가 다운되더라도 데이터가 안전하게 보호됨

##### 데이터 일관성

- 다중화된 데이터는 적절히 동기화되어야함
- 정족수 합의 (Quorum Consensus)
  - N개의 복제본 중 W개의 복제본이 쓰기를 수행하고 R개의 복제본이 읽기를 수행하면 데이터 일관성을 보장할 수 있음
  - W + R > N
  - W = N, R = 1
  - W = 1, R = N
- 데이터 일관성 수준
  - 강한 일관성 (Strong Consistency): 모든 복제본이 동일한 데이터를 가지고 있음
  - 약한 일관성 (Weak Consistency): 모든 복제본이 동일한 데이터를 가지고 있지 않음
  - 최종 일관성 (Eventual Consistency): 시간이 지나면 모든 복제본이 동일한 데이터를 가지고 있음

##### 일관성 불일치 해결빙법: 데이터 버저닝

- 데이터 다중화로 가용성은 높아지지만 일관성이 깨질 가능성은 높아짐
- 버저닝, 벡터 시계 이용 가능
- 버저닝: 데이터를 변경할 때마다 해당 데이터의 새로운 버전을 만드는 것. 각 버전의 데이터는 변경 불가능
- 벡터 시계: 데이터 충돌을 발견하고 자동으로 해결해 주는 알고리즘
  - [서버, 버전] 순서쌍을 데이터에 메달음
  - 어떤 서버에서 데이터를 변경하면 해당 서버의 버전을 증가시킴
- 이미지
- 버전 X와 Y사이에 충돌이 있는지 보려면 Y의 벡터 시계 구성요소 가운데 X의 구성요소보다 작은 값이 있는지 확인
- 단점1: 클라이언트 구현이 복잡해짐
- 단점2: 서버, 버전 순서쌍 개수가 굉장히 빠르게 늘어남
  - 오래된 순서쌍을 벡터 시계에서 제거라도록 해야함 -> 충돌 효율성은 낮아짐

##### 장애 감지

- 두대 이상의 서버가 똑같이 서버 A의 장애를 보고하면 서버에 실제로 장애가 발생했다고 간주함
- 모든 노드 사이에 멀티캐스팅 채널을 구축하여 서버 장애를 감지하는게 가장 좋음
  - 하지만 서버가 많을 때는 비효율적
- 가십프로토콜 (분산형 장애 감지 솔루션)
  - 각 노드는 멤버십 목록을 가짐
  - 멤버십 목록은 멤버 ID, 박통 카운터 쌍의 목록
  - 각 노드는 무작위로 선정된 노드에 주기적으로 자기 박동 카운터 목록을 보냄
- 박동 카운터 목록을 받은 노드는 멤버십 목록을 최신 값으로 갱신
- `어떤 멤버의 박동 카운터가 일정 시간동안 갱신되지 않으면 해당 멤버는 장애가 발생했다고 판단`

##### 일시적 장애 처리

- 장애를 감지한 시스템은 가용성을 보장하기 위해 필요한 조치를 해야함
- 엄격한 정족수 기법: 읽기와 쓰기 연산 금지
- 느슨한 정족수 기법: 쓰기 연산을 수행할 W개의 서버와 읽기 연산을 수행할 R개의 서버를 해시 링에서 선택 (장애 상태인 서버는 무시함)
-
